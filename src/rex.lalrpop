use crate::ast::{NodeType,Node};

grammar;

pub rexStmtList: Node = {
    <s:rexStmt> <sl:rexStmtList> => s.add_stmt_list(sl),
    rexStmt => <>,
}

rexStmt: Node = {
    MATCH <e:rexExpr> SEMI => e,
    LET <id:Id> BE <re:rexExpr> SEMI => re.create_variable(id),
};

rexExpr: Node = {
    <re:rexExpr> OR <rt:rexTerm> => Node::new(&[re, rt], NodeType::Union),
    rexTerm,
};

rexTerm: Node = {
    <rt:rexTerm> AND <rf:rexFactor> => Node::new(&[rt, rf], NodeType::Concat),
    rexFactor,
};

rexFactor: Node = {
    <rf:rexFactor> REPEAT => Node::new(&[rf], NodeType::Star),
    rexUnit,
};

rexUnit: Node = {
    Str => Node::new_str(<>),
    Id  => Node::new(&[], NodeType::Id).set_value(<>),
    LB <re:rexExpr> RB => re,
};

////////////
// TOKENS //
////////////
match {
   r"\$(\w*)" => Id,
    "match"   => MATCH,
    "let"     => LET,
    "be"      => BE,
    "or"      => OR,
    "and"     => AND,
    "repeat"  => REPEAT,
    "{"       => LB,
    "}"       => RB,
    ";"       => SEMI,
    "\n"      => NL,
} else {
   r"\w+"     => Str, // separate because the regex overlaps with Id
}
